/*
 *This class could be responsible for building a Batfish-specific configuration representation or data structure
 *from the parsed configuration file using the parse tree generated by the "RgosCombinedParser.java" class.
 */
package org.batfish.grammar.rgos;

import static com.google.common.base.Preconditions.checkArgument;
// import com.google.common.collect.ImmutableSortedSet;

// import static java.util.Comparator.naturalOrder;

import com.google.common.collect.Range;
import java.util.Optional;
import java.util.regex.Pattern;
import javax.annotation.Nonnull;
import javax.annotation.ParametersAreNonnullByDefault;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.tree.ErrorNode;
import org.batfish.common.Warnings;
import org.batfish.common.Warnings.ParseWarning;
import org.batfish.datamodel.ConcreteInterfaceAddress;
import org.batfish.datamodel.Ip;
import org.batfish.datamodel.Ip6;
import org.antlr.v4.runtime.tree.TerminalNode;

import org.batfish.datamodel.IntegerSpace;
import org.batfish.datamodel.SubRange;
import static org.batfish.representation.rgos.RgosStructureType.INTERFACE;
import static org.batfish.representation.rgos.RgosStructureUsage.INTERFACE_SELF_REF;

// import org.batfish.datamodel.Ip;
// import org.batfish.datamodel.Prefix;
import org.batfish.grammar.BatfishCombinedParser;
import org.batfish.grammar.SilentSyntaxListener;
import org.batfish.grammar.UnrecognizedLineToken;

import org.batfish.common.BatfishException;
import com.google.common.collect.ImmutableList;
import java.util.ArrayList;
import java.util.List;

import org.batfish.grammar.rgos.RgosParser.S_interface_definitionContext;
import org.batfish.grammar.rgos.RgosParser.S_hostnameContext;
import org.batfish.grammar.rgos.RgosParser.Interface_nameContext;
import org.batfish.grammar.rgos.RgosParser.If_ip_addressContext;


import org.batfish.representation.rgos.Interface;
import org.batfish.representation.rgos.Vrf;
import org.batfish.grammar.rgos.RgosParser.RangeContext;
import org.batfish.grammar.rgos.RgosParser.RangeContext;
import org.batfish.grammar.rgos.RgosParser.SubrangeContext;


// import org.batfish.grammar.rgos.RgosParser.Host_nameContext;
// import org.batfish.grammar.rgos.RgosParser.Ipv4_addressContext;
// import org.batfish.grammar.rgos.RgosParser.Ipv4_prefixContext;
// import org.batfish.grammar.rgos.RgosParser.S_lineContext;
// import org.batfish.grammar.rgos.RgosParser.Ss_addContext;
// import org.batfish.grammar.rgos.RgosParser.Ss_deleteContext;
// import org.batfish.grammar.rgos.RgosParser.Ss_disableContext;
// import org.batfish.grammar.rgos.RgosParser.Ss_enableContext;
// import org.batfish.grammar.rgos.RgosParser.Ss_modifyContext;
// import org.batfish.grammar.rgos.RgosParser.Ssa_discardContext;
// import org.batfish.grammar.rgos.RgosParser.Ssa_gatewayContext;
// import org.batfish.grammar.rgos.RgosParser.Ssa_interfaceContext;
// import org.batfish.grammar.rgos.RgosParser.Ssy_host_nameContext;
// import org.batfish.grammar.rgos.RgosParser.Rgos_versionContext;
// import org.batfish.grammar.rgos.RgosParser.StringContext;
// import org.batfish.grammar.rgos.RgosParser.Uint16Context;
import org.batfish.grammar.rgos.RgosParser.Uint8Context;
import org.batfish.grammar.rgos.RgosParser.DecContext;
import org.batfish.grammar.rgos.RgosParser.Vlan_idContext;
import org.batfish.grammar.silent_syntax.SilentSyntaxCollection;
import org.batfish.representation.rgos.RgosConfiguration;
import org.batfish.representation.rgos.NextHop;
// import org.batfish.vendor.rgos.NextHopDiscard;
// import org.batfish.vendor.rgos.NextHopGateway;
// import org.batfish.vendor.rgos.NextHopInterface;
import org.batfish.representation.rgos.StaticRoute;

@ParametersAreNonnullByDefault
public final class RgosConfigurationBuilder extends RgosParserBaseListener
    implements SilentSyntaxListener {

  public RgosConfigurationBuilder(
      RgosCombinedParser parser,
      String text,
      Warnings warnings,
      SilentSyntaxCollection silentSyntax) {
    _parser = parser;
    _text = text;
    _configuration = new RgosConfiguration();
    _configuration.setExtraLines(_parser.getExtraLines());
    _w = warnings;
    _silentSyntax = silentSyntax;
  }

  /**
   * Convert a {@link ParserRuleContext} whose text is guaranteed to represent a valid signed 32-bit
   * decimal integer to an {@link Integer} if it is contained in the provided {@code space}, or else
   * {@link Optional#empty}.
   *
   * <p>This function should only be called by more strictly typed overloads of {@code
   * toIntegerSpace}.
   */
  private @Nonnull Optional<Integer> toIntegerInSpace_helper(
      ParserRuleContext messageCtx, ParserRuleContext ctx, IntegerSpace space, String name) {
    int num = Integer.parseInt(ctx.getText());
    if (!space.contains(num)) {
      warn(messageCtx, String.format("Expected %s in range %s, but got '%d'", name, space, num));
      return Optional.empty();
    }
    return Optional.of(num);
  }

  private static @Nonnull String unquote(String text) {
    if (text.length() == 0) {
      return text;
    }
    if (text.charAt(0) != '"') {
      return text;
    }
    // Here for sanity, but should not trigger unless the definition of string rule is broken.
    checkArgument(text.charAt(text.length() - 1) == '"', "Improperly-quoted string: %s", text);
    return text.substring(1, text.length() - 1);
  }

  @Override
  public void visitErrorNode(ErrorNode errorNode) {
    Token token = errorNode.getSymbol();
    int line = token.getLine();
    String lineText = errorNode.getText().replace("\n", "").replace("\r", "").trim();
    _configuration.setUnrecognized(true);

    if (token instanceof UnrecognizedLineToken) {
      UnrecognizedLineToken unrecToken = (UnrecognizedLineToken) token;
      _w.getParseWarnings()
          .add(
              new ParseWarning(
                  line, lineText, unrecToken.getParserContext(), "This syntax is unrecognized"));
    } else {
      String msg = String.format("Unrecognized Line: %d: %s", line, lineText);
      _w.redFlag(msg + " SUBSEQUENT LINES MAY NOT BE PROCESSED CORRECTLY");
    }
  }

  @Override
  public void exitS_hostname(S_hostnameContext ctx) {
    String hostname;
    if (ctx.quoted_name != null) {
      hostname = unquote(ctx.quoted_name.getText());
    } else {
      StringBuilder sb = new StringBuilder();
      for (Token namePart : ctx.name_parts) {
        sb.append(namePart.getText());
      }
      hostname = sb.toString();
    }
    _configuration.setHostname(hostname);
    _configuration.getRf().setHostname(hostname);
  }

  @Override
  public void enterS_interface_definition(S_interface_definitionContext ctx) {
    String nameAlpha = ctx.iname.name_prefix_alpha.getText();
    String canonicalNamePrefix;
    try {
      canonicalNamePrefix = RgosConfiguration.getCanonicalInterfaceNamePrefix(nameAlpha);
    } catch (BatfishException e) {
      warn(ctx, "Error fetching interface name: " + e.getMessage());
      _currentInterfaces = ImmutableList.of();
      return;
    }
    StringBuilder namePrefix = new StringBuilder(canonicalNamePrefix);
    for (Token part : ctx.iname.name_middle_parts) {
      namePrefix.append(part.getText());
    }
    _currentInterfaces = new ArrayList<>();
    if (ctx.iname.range() != null) {
      List<SubRange> ranges = toRange(ctx.iname.range());
      for (SubRange range : ranges) {
        for (int i = range.getStart(); i <= range.getEnd(); i++) {
          String name = namePrefix.toString() + i;
          addInterface(name, ctx.iname, true);
          _configuration.defineStructure(INTERFACE, name, ctx);
          System.out.println("ctx.getStart().getLine()--------" + ctx.getStart().getLine());
          _configuration.referenceStructure(
              INTERFACE, name, INTERFACE_SELF_REF, ctx.getStart().getLine());
        }
      }
    } else {
      addInterface(namePrefix.toString(), ctx.iname, true);
    }
    if (ctx.MULTIPOINT() != null) {
      todo(ctx);
    }
  }

  @Override
  public void exitS_interface_definition(S_interface_definitionContext ctx) {
    _currentInterfaces = null;
  }

  @Override
  public void exitIf_ip_address(If_ip_addressContext ctx) {
    ConcreteInterfaceAddress address;
    if (ctx.prefix != null) {
      address = ConcreteInterfaceAddress.parse(ctx.prefix.getText());
    } else {
      Ip ip = toIp(ctx.ip);
      Ip mask = toIp(ctx.subnet);
      address = ConcreteInterfaceAddress.create(ip, mask);
    }
    for (Interface currentInterface : _currentInterfaces) {
      currentInterface.setAddress(address);
    }
    if (ctx.STANDBY() != null) {
      Ip standbyIp = toIp(ctx.standby_address);
      ConcreteInterfaceAddress standbyAddress =
          ConcreteInterfaceAddress.create(standbyIp, address.getNetworkBits());
      for (Interface currentInterface : _currentInterfaces) {
        currentInterface.setStandbyAddress(standbyAddress);
      }
    }
    if (ctx.ROUTE_PREFERENCE() != null) {
      warn(ctx, "Unsupported: route-preference declared in interface IP address");
    }
    if (ctx.TAG() != null) {
      warn(ctx, "Unsupported: tag declared in interface IP address");
    }
  }


  @Override
  public void exitEveryRule(ParserRuleContext ctx) {
    tryProcessSilentSyntax(ctx);
  }

  @Override
  public @Nonnull SilentSyntaxCollection getSilentSyntax() {
    return _silentSyntax;
  }

  @Override
  public @Nonnull String getInputText() {
    return _text;
  }

  @Override
  public @Nonnull BatfishCombinedParser<?, ?> getParser() {
    return _parser;
  }

  @Override
  public @Nonnull Warnings getWarnings() {
    return _w;
  }

  public @Nonnull RgosConfiguration getConfiguration() {
    return _configuration;
  }

  private Interface addInterface(String name, Interface_nameContext ctx, boolean explicit) {
    Interface newInterface = _configuration.getInterfaces().get(name);
    if (newInterface == null) {
      newInterface = new Interface(name, _configuration);
      _configuration.getInterfaces().put(name, newInterface);
      initInterface(newInterface, ctx);
    } else {
      _w.pedantic("Interface: '" + name + "' altered more than once");
    }
    // newInterface.setDeclaredNames(
    //     new ImmutableSortedSet.Builder<String>(naturalOrder())
    //         .addAll(newInterface.getDeclaredNames())
    //         .add(ctx.getText())
    //         .build());
    if (explicit) {
      _currentInterfaces.add(newInterface);
    }
    return newInterface;
  }


  private void initInterface(Interface iface, Interface_nameContext ctx) {
    System.out.println("initinterface----");
    String nameAlpha = ctx.name_prefix_alpha.getText();
    String canonicalNamePrefix = RgosConfiguration.getCanonicalInterfaceNamePrefix(nameAlpha);
    String vrf =
        canonicalNamePrefix.equals(RgosConfiguration.MANAGEMENT_INTERFACE_PREFIX)
            ? RgosConfiguration.MANAGEMENT_VRF_NAME
            : RgosConfiguration.DEFAULT_VRF_NAME;
    int mtu = Interface.getDefaultMtu();
    iface.setVrf(vrf);
    initVrf(vrf);
    iface.setMtu(mtu);
  }

  private Vrf initVrf(String vrfName) {
    return _configuration.getVrfs().computeIfAbsent(vrfName, Vrf::new);
  }
  private static Ip toIp(TerminalNode t) {
    return Ip.parse(t.getText());
  }

  private static Ip toIp(Token t) {
    return Ip.parse(t.getText());
  }

  private static Ip6 toIp6(Token t) {
    return Ip6.parse(t.getText());
  }

  private static long toLong(DecContext ctx) {
    return Long.parseLong(ctx.getText());
  }

  private static SubRange toSubRange(SubrangeContext ctx) {
    int low = toInteger(ctx.low);
    if (ctx.DASH() != null) {
      int high = toInteger(ctx.high);
      return new SubRange(low, high);
    } else {
      return SubRange.singleton(low);
    }
  }

  private static List<SubRange> toRange(RangeContext ctx) {
    List<SubRange> range = new ArrayList<>();
    for (SubrangeContext sc : ctx.range_list) {
      SubRange sr = toSubRange(sc);
      range.add(sr);
    }
    return range;
  }
  private static int toInteger(Uint8Context ctx) {
    return Integer.parseInt(ctx.getText());
  }

  private static int toInteger(DecContext ctx) {
    return Integer.parseInt(ctx.getText());
  }

  private static int toInteger(Token t) {
    return Integer.parseInt(t.getText());
  }

  private static int toInteger(Vlan_idContext ctx) {
    return Integer.parseInt(ctx.getText(), 10);
  }


  private final @Nonnull RgosCombinedParser _parser;
  private final @Nonnull String _text;
  private final @Nonnull RgosConfiguration _configuration;
  private final @Nonnull Warnings _w;
  private final @Nonnull SilentSyntaxCollection _silentSyntax;

  private StaticRoute _currentStaticRoute;
  private NextHop _currentNextHop;
  private List<Interface> _currentInterfaces;

  private static final IntegerSpace HOSTNAME_LENGTH_RANGE = IntegerSpace.of(Range.closed(1, 32));
  private static final IntegerSpace VLAN_NUMBER_RANGE = IntegerSpace.of(Range.closed(1, 4094));
  private static final Pattern HOSTNAME_PATTERN =
      Pattern.compile("[-A-Za-z0-9]+(\\.[-A-Za-z0-9]+)*");
}
